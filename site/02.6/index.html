<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>2.6 interface - My Docs</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "2.6 interface";
    var mkdocs_page_input_path = "02.6.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> My Docs</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">0.0目录</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../01.0/">1.0 GO环境配置</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../01.1/">1.1安装 Go</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../01.2/">1.2 GOPATH与工作空间</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../01.3/">1.3 Go 命令</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../01.4/">1.4 Go开发工具</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../01.5/">1.5 总结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02.0/">2 Go语言基础</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02.1/">2.1 你好，Go</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02.2/">2.2 Go基础</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02.3/">2.3 流程和函数</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02.4/">2.4 struct类型</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02.5/">2.5 面向对象</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">2.6 interface</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#26-interface">2.6 interface</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#interface">interface</a></li>
        
            <li><a class="toctree-l3" href="#links">links</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02.7/">2.7 并发</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02.8/">2.8 总结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../03.0/">3 Web基础</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../03.1/">3.1 Web工作方式</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../03.2/">3.2 Go搭建一个Web服务器</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../03.3/">3.3 Go如何使得Web工作</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../03.4/">3.4 Go的http包详解</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../03.5/">3.5 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04.0/">4 表单</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04.1/">4.1 处理表单的输入</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04.2/">4.2 验证表单的输入</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04.3/">4.3 预防跨站脚本</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04.4/">4.4 防止多次递交表单</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04.5/">4.5 处理文件上传</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04.6/">4.6 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05.0/">5 访问数据库</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05.1/">5.1 database/sql接口</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05.2/">5.2 使用MySQL数据库</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05.3/">5.3 使用SQLite数据库</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05.4/">5.4 使用PostgreSQL数据库</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05.5/">5.5 使用Beego orm库进行ORM开发</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05.6/">5.6 NOSQL数据库操作</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05.7/">5.7 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../06.0/">6 session和数据存储</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../06.1/">6.1 session和cookie</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../06.2/">6.2 Go如何使用session</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../06.3/">6.3 session存储</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../06.4/">6.4 预防session劫持</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../06.5/">6.5 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07.0/">7 文本处理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07.1/">7.1 XML处理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07.2/">7.2 JSON处理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07.3/">7.3 正则处理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07.4/">7.4 模板处理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07.5/">7.5 文件操作</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07.6/">7.6 字符串处理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07.7/">7.7 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../08.0/">8 Web服务</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../08.1/">8.1 Socket编程</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../08.2/">8.2 WebSocket</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../08.3/">8.3 REST</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../08.4/">8.4 RPC</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../08.5/">8.5 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09.0/">9 安全与加密</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09.1/">9.1 预防CSRF攻击</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09.2/">9.2 确保输入过滤</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09.3/">9.3 避免XSS攻击</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09.4/">9.4 避免SQL注入</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09.5/">9.5 存储密码</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09.6/">9.6 加密和解密数据</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09.7/">9.7 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../10.0/">10 国际化和本地化</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../10.1/">10.1 设置默认地区</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../10.2/">10.2 本地化资源</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../10.3/">10.3 国际化站点</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../10.4/">10.4 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../11.0/">11 错误处理，调试和测试</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../11.1/">11.1 错误处理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../11.2/">11.2 使用GDB调试</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../11.3/">11.3 Go怎么写测试用例</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../11.4/">11.4 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../12.0/">12 部署与维护</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../12.1/">12.1 应用日志</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../12.2/">12.2 网站错误处理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../12.3/">12.3 应用部署</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../12.4/">12.4 备份和恢复</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../12.5/">12.5 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../13.0/">13 如何设计一个Web框架</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../13.1/">13.1 项目规划</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../13.2/">13.2 自定义路由器设计</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../13.3/">13.3 controller设计</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../13.4/">13.4 日志和配置设计</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../13.5/">13.5 实现博客的增删改</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../13.6/">13.6 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14.0/">14 扩展Web框架</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14.1/">14.1 静态文件支持</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14.2/">14.2 Session支持</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14.3/">14.3 表单及验证支持</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14.4/">14.4 用户认证</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14.5/">14.5 多语言支持</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14.6/">14.6 pprof支持</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14.7/">14.7 小结</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../preface/">0.0目录</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../ref/">附录A 参考资料</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">My Docs</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>2.6 interface</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="26-interface">2.6 interface</h1>
<h2 id="interface">interface</h2>
<p>Go语言里面设计最精妙的应该算interface，它让面向对象，内容组织实现非常的方便，当你看完这一章，你就会被interface的巧妙设计所折服。</p>
<h3 id="interface_1">什么是interface</h3>
<p>简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为。</p>
<p>我们前面一章最后一个例子中Student和Employee都能SayHi，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能<code>say hi</code></p>
<p>让我们来继续做更多的扩展，Student和Employee实现另一个方法<code>Sing</code>，然后Student实现方法BorrowMoney而Employee实现SpendSalary。</p>
<p>这样Student实现了三个方法：SayHi、Sing、BorrowMoney；而Employee实现了SayHi、Sing、SpendSalary。</p>
<p>上面这些方法的组合称为interface(被对象Student和Employee实现)。例如Student和Employee都实现了interface：SayHi和Sing，也就是这两个对象是该interface类型。而Employee没有实现这个interface：SayHi、Sing和BorrowMoney，因为Employee没有实现BorrowMoney这个方法。</p>
<h3 id="interface_2">interface类型</h3>
<p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子</p>
<pre><code class="Go">
type Human struct {
    name string
    age int
    phone string
}

type Student struct {
    Human //匿名字段Human
    school string
    loan float32
}

type Employee struct {
    Human //匿名字段Human
    company string
    money float32
}

//Human对象实现Sayhi方法
func (h *Human) SayHi() {
    fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)
}

// Human对象实现Sing方法
func (h *Human) Sing(lyrics string) {
    fmt.Println(&quot;La la, la la la, la la la la la...&quot;, lyrics)
}

//Human对象实现Guzzle方法
func (h *Human) Guzzle(beerStein string) {
    fmt.Println(&quot;Guzzle Guzzle Guzzle...&quot;, beerStein)
}

// Employee重载Human的Sayhi方法
func (e *Employee) SayHi() {
    fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,
        e.company, e.phone) //此句可以分成多行
}

//Student实现BorrowMoney方法
func (s *Student) BorrowMoney(amount float32) {
    s.loan += amount // (again and again and...)
}

//Employee实现SpendSalary方法
func (e *Employee) SpendSalary(amount float32) {
    e.money -= amount // More vodka please!!! Get me through the day!
}

// 定义interface
type Men interface {
    SayHi()
    Sing(lyrics string)
    Guzzle(beerStein string)
}

type YoungChap interface {
    SayHi()
    Sing(song string)
    BorrowMoney(amount float32)
}

type ElderlyGent interface {
    SayHi()
    Sing(song string)
    SpendSalary(amount float32)
}
</code></pre>

<p>通过上面的代码我们可以知道，interface可以被任意的对象实现。我们看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。</p>
<p>最后，任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface。</p>
<h3 id="interface_3">interface值</h3>
<p>那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p>
<p>因为m能够持有这三种类型的对象，所以我们可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和我们传统意义上面的slice有所不同。</p>
<p>让我们来看一下下面这个例子:</p>
<pre><code class="Go">
package main

import &quot;fmt&quot;

type Human struct {
    name string
    age int
    phone string
}

type Student struct {
    Human //匿名字段
    school string
    loan float32
}

type Employee struct {
    Human //匿名字段
    company string
    money float32
}

//Human实现SayHi方法
func (h Human) SayHi() {
    fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)
}

//Human实现Sing方法
func (h Human) Sing(lyrics string) {
    fmt.Println(&quot;La la la la...&quot;, lyrics)
}

//Employee重载Human的SayHi方法
func (e Employee) SayHi() {
    fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,
        e.company, e.phone)
    }

// Interface Men被Human,Student和Employee实现
// 因为这三个类型都实现了这两个方法
type Men interface {
    SayHi()
    Sing(lyrics string)
}

func main() {
    mike := Student{Human{&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;}, &quot;MIT&quot;, 0.00}
    paul := Student{Human{&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;}, &quot;Harvard&quot;, 100}
    sam := Employee{Human{&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;}, &quot;Golang Inc.&quot;, 1000}
    tom := Employee{Human{&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;}, &quot;Things Ltd.&quot;, 5000}

    //定义Men类型的变量i
    var i Men

    //i能存储Student
    i = mike
    fmt.Println(&quot;This is Mike, a Student:&quot;)
    i.SayHi()
    i.Sing(&quot;November rain&quot;)

    //i也能存储Employee
    i = tom
    fmt.Println(&quot;This is tom, an Employee:&quot;)
    i.SayHi()
    i.Sing(&quot;Born to be wild&quot;)

    //定义了slice Men
    fmt.Println(&quot;Let's use a slice of Men and see what happens&quot;)
    x := make([]Men, 3)
    //这三个都是不同类型的元素，但是他们实现了interface同一个接口
    x[0], x[1], x[2] = paul, sam, mike

    for _, value := range x{
        value.SayHi()
    }
}
</code></pre>

<p>通过上面的代码，你会发现interface就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了duck-typing:即"当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子"。</p>
<h3 id="interface_4">空interface</h3>
<p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p>
<pre><code class="Go">
// 定义a为空接口
var a interface{}
var i int = 5
s := &quot;Hello world&quot;
// a可以存储任意类型的数值
a = i
a = s
</code></pre>

<p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值。是不是很有用啊！</p>
<h3 id="interface_5">interface函数参数</h3>
<p>interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数。</p>
<p>举个例子：fmt.Println是我们常用的一个函数，但是你是否注意到它可以接受任意类型的数据。打开fmt的源码文件，你会看到这样一个定义:</p>
<pre><code class="Go">
type Stringer interface {
     String() string
}
</code></pre>

<p>也就是说，任何实现了String方法的类型都能作为参数被fmt.Println调用,让我们来试一试</p>
<pre><code class="Go">
package main
import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

type Human struct {
    name string
    age int
    phone string
}

// 通过这个方法 Human 实现了 fmt.Stringer
func (h Human) String() string {
    return &quot;❰&quot;+h.name+&quot; - &quot;+strconv.Itoa(h.age)+&quot; years -  ✆ &quot; +h.phone+&quot;❱&quot;
}

func main() {
    Bob := Human{&quot;Bob&quot;, 39, &quot;000-7777-XXX&quot;}
    fmt.Println(&quot;This Human is : &quot;, Bob)
}
</code></pre>

<p>现在我们再回顾一下前面的Box示例，你会发现Color结构也定义了一个method：String。其实这也是实现了fmt.Stringer这个interface，即如果需要某个类型能被fmt包以特殊的格式输出，你就必须实现Stringer这个接口。如果没有实现这个接口，fmt将以默认的方式输出。</p>
<pre><code class="Go">
//实现同样的功能
fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestsColor().String())
fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestsColor())
</code></pre>

<p>注：实现了error接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p>
<h3 id="interface_6">interface变量存储的类型</h3>
<p>我们知道interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么我们怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p>
<ul>
<li>
<p>Comma-ok断言</p>
<p>Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p>
<p>如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。</p>
<p>让我们通过一个例子来更加深入的理解。</p>
</li>
</ul>
<pre><code class="Go">
    package main

    import (
        &quot;fmt&quot;
        &quot;strconv&quot;
    )

    type Element interface{}
    type List [] Element

    type Person struct {
        name string
        age int
    }

    //定义了String方法，实现了fmt.Stringer
    func (p Person) String() string {
        return &quot;(name: &quot; + p.name + &quot; - age: &quot;+strconv.Itoa(p.age)+ &quot; years)&quot;
    }

    func main() {
        list := make(List, 3)
        list[0] = 1 // an int
        list[1] = &quot;Hello&quot; // a string
        list[2] = Person{&quot;Dennis&quot;, 70}

        for index, element := range list {
            if value, ok := element.(int); ok {
                fmt.Printf(&quot;list[%d] is an int and its value is %d\n&quot;, index, value)
            } else if value, ok := element.(string); ok {
                fmt.Printf(&quot;list[%d] is a string and its value is %s\n&quot;, index, value)
            } else if value, ok := element.(Person); ok {
                fmt.Printf(&quot;list[%d] is a Person and its value is %s\n&quot;, index, value)
            } else {
                fmt.Printf(&quot;list[%d] is of a different type\n&quot;, index)
            }
        }
    }
</code></pre>

<pre><code>是不是很简单啊，同时你是否注意到了多个if里面，还记得我前面介绍流程时讲过，if里面允许初始化变量。

也许你注意到了，我们断言的类型越多，那么if else也就越多，所以才引出了下面要介绍的switch。
</code></pre>
<ul>
<li>
<p>switch测试</p>
<p>最好的讲解就是代码例子，现在让我们重写上面的这个实现</p>
</li>
</ul>
<pre><code class="Go">
    package main

    import (
        &quot;fmt&quot;
        &quot;strconv&quot;
    )

    type Element interface{}
    type List [] Element

    type Person struct {
        name string
        age int
    }

    //打印
    func (p Person) String() string {
        return &quot;(name: &quot; + p.name + &quot; - age: &quot;+strconv.Itoa(p.age)+ &quot; years)&quot;
    }

    func main() {
        list := make(List, 3)
        list[0] = 1 //an int
        list[1] = &quot;Hello&quot; //a string
        list[2] = Person{&quot;Dennis&quot;, 70}

        for index, element := range list{
            switch value := element.(type) {
                case int:
                    fmt.Printf(&quot;list[%d] is an int and its value is %d\n&quot;, index, value)
                case string:
                    fmt.Printf(&quot;list[%d] is a string and its value is %s\n&quot;, index, value)
                case Person:
                    fmt.Printf(&quot;list[%d] is a Person and its value is %s\n&quot;, index, value)
                default:
                    fmt.Println(&quot;list[%d] is of a different type&quot;, index)
            }
        }
    }
</code></pre>

<pre><code>这里有一点需要强调的是：`element.(type)`语法不能在switch外的任何逻辑里面使用，如果你要在switch外面判断一个类型就使用`comma-ok`。
</code></pre>
<h3 id="interface_7">嵌入interface</h3>
<p>Go里面真正吸引人的是它内置的逻辑语法，就像我们在学习Struct时学习的匿名字段，多么的优雅啊，那么相同的逻辑引入到interface里面，那不是更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。</p>
<p>我们可以看到源码包container/heap里面有这样的一个定义</p>
<pre><code class="Go">
type Interface interface {
    sort.Interface //嵌入字段sort.Interface
    Push(x interface{}) //a Push method to push elements into the heap
    Pop() interface{} //a Pop elements that pops elements from the heap
}
</code></pre>

<p>我们看到sort.Interface其实就是嵌入字段，把sort.Interface的所有method给隐式的包含进来了。也就是下面三个方法：</p>
<pre><code class="Go">
type Interface interface {
    // Len is the number of elements in the collection.
    Len() int
    // Less returns whether the element with index i should sort
    // before the element with index j.
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    Swap(i, j int)
}
</code></pre>

<p>另一个例子就是io包下面的 io.ReadWriter ，它包含了io包下面的Reader和Writer两个interface：</p>
<pre><code class="Go">
// io.ReadWriter
type ReadWriter interface {
    Reader
    Writer
}
</code></pre>

<h3 id="_1">反射</h3>
<p>Go语言实现了反射，所谓反射就是能检查程序在运行时的状态。我们一般用到的包是reflect包。如何运用reflect包，官方的这篇文章详细的讲解了reflect包的实现原理，<a href="http://golang.org/doc/articles/laws_of_reflection.html">laws of reflection</a></p>
<p>使用reflect一般分成三步，下面简要的讲解一下：要去反射是一个类型的值(这些值都实现了空interface)，首先需要把它转化成reflect对象(reflect.Type或者reflect.Value，根据不同的情况调用不同的函数)。这两种获取方式如下：</p>
<pre><code class="Go">
t := reflect.TypeOf(i)    //得到类型的元数据,通过t我们能获取类型定义里面的所有元素
v := reflect.ValueOf(i)   //得到实际的值，通过v我们获取存储在里面的值，还可以去改变值
</code></pre>

<p>转化为reflect对象之后我们就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如</p>
<pre><code class="Go">
tag := t.Elem().Field(0).Tag  //获取定义在struct里面的标签
name := v.Elem().Field(0).String()  //获取存储在第一个字段里面的值
</code></pre>

<p>获取反射值能返回相应的类型和数值</p>
<pre><code class="Go">
var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println(&quot;type:&quot;, v.Type())
fmt.Println(&quot;kind is float64:&quot;, v.Kind() == reflect.Float64)
fmt.Println(&quot;value:&quot;, v.Float())
</code></pre>

<p>最后，反射的话，那么反射的字段必须是可修改的，我们前面学习过传值和传引用，这个里面也是一样的道理。反射的字段必须是可读写的意思是，如果下面这样写，那么会发生错误</p>
<pre><code class="Go">
var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1)
</code></pre>

<p>如果要修改相应的值，必须这样写</p>
<pre><code class="Go">
var x float64 = 3.4
p := reflect.ValueOf(&amp;x)
v := p.Elem()
v.SetFloat(7.1)
</code></pre>

<p>上面只是对反射的简单介绍，更深入的理解还需要自己在编程中不断的实践。</p>
<h2 id="links">links</h2>
<ul>
<li><a href="../preface/">目录</a></li>
<li>上一章: <a href="../02.5/">面向对象</a></li>
<li>下一节: <a href="../02.7/">并发</a></li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../02.7/" class="btn btn-neutral float-right" title="2.7 并发">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../02.5/" class="btn btn-neutral" title="2.5 面向对象"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../02.5/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../02.7/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
